### 事件循环引入
*   每一个浏览器都至少有一个事件循环，每一个事件循环至少有一个任务队列，循环指的是其永远处于一个无限循环中，不断将注册的回调函数推入到执行栈中。
*   浏览器事件循环 vs NodeJS事件循环
*   JS引擎的作用：讲JS文本变成一段机器可以理解的计算机指令（V8：只有栈和堆）
*   执行（上下文）栈 & 堆（内存）
*   浏览器或者Node的作用是啥
    *   执行环境，提供JS可以调用的API
*   JS执行栈和渲染线程相互阻塞
*   设计模式：单线程 + 异步
    *   事件循环：调度器，决定V8什么时候执行代码
*   小结：
    *   V8
        *   一个调用栈，同一时间只能执行一段代码
        *   堆
    *   浏览器运行环境
        *   WEB API
        *   DOM API
        *   任务队列
    *   事件循环
        *   碰到异步代码，浏览器会将用户注册的回调函数存起来跑后面的代码，异步任务完成了，触发事件，浏览器会将“任务的详细信息”作为参数传递给之前用户绑定的回调函数=>将用户绑定的回调函数推入浏览器的执行栈
        *   如果没有绑定回调，执行完的消息无效，没有函数加入执行栈
*   宏任务与微任务
    ```
    执行顺序.js
    console.log(1);
    setTime(()=>{console.log(2)},0)
    Promise.resolve().then(()=>{
        return console.log(3);
    }).then(()=>{
        console.log(4)
    })
    console.log(5)
    //输出
    //1，5，3，4，2
    ```
*   简单解释
    *   浏览器首先执行宏任务<script>
    *   完成之后检查是否存在微任务，不断执行，直到清空队列
    *   执行宏任务
*   宏任务
    *   setTimeout, setInterval, I/O, UI交互事件
*   微任务
    *   Promise
    

       
